/*Practica final
version 0.0.0.2
Luis Buegos Vidales y Jose Doyague Hernandez
*/

/*En el programa tenemos el mismo error repetido 33 veces y no sabemos que hacer para solucionarlo
el error es  Error: invalid use of inclomplete type 'struct nodo' y aparente lo tenemos bien declado*/

#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <string.h>
#include <errno.h>

typedef struct datos{
  char  *imagen;
}dato;

typedef struct nodo{
  struct nodo *nodo_siguiente;
  dato nombre;
  struct nodo *nodo_anterior;
} nodo;

nodo* insertaFinal(nodo *nuevoNodo, nodo *ptrFinal,nodo *ptrCabecera);//inserta al final
void mostrarLista(nodo *ptrCabecera, nodo *ptrFinal);
void visualiza(datos fotografia);
nodo* borrar(nodo *nuevoNodo, nodo *ptrFinal ,nodo *ptrCabecera, nodo *ptrSiguiente);

void error(const char *s);

void procesoArchivo(char *archivo);


/*MAIN*/
int main(int argc, char const *argv[]) {
  //leemos datos de un fichero y los metemos en una lista
  FILE *fichero;
  dato fotografia;
  nodo *ptrCabecera, *ptrFinal, *ptrSiguiente;
  ptrCabecera = NULL;
  ptrFinal = NULL;
  int menu;
/*cambiar por ejemplo del directorio de la Practica*/
DIR *dir;
struct dirent *ent;
dir = opendir (".");
if (dir == NULL){
  error("No puedo abrir el directorio");
}
while ((ent = readdir (dir)) != NULL) {
    /* Nos devolverá el directorio actual (.) y el anterior (..), como hace ls */
    if ( (strcmp(ent->d_name, ".")!=0) && (strcmp(ent->d_name, "..")!=0) )
    fotografia = ent->d_name;
  {
    fotografia = ent->d_name;
    nodo *nuevoNodo;
    nuevoNodo = (nodo *)malloc(sizeof(nodo));//reservamos espacio para el nuevo nodo
    nuevoNodo->nombre = fotografia;// guardamos la estructura en el nodo
    nuevoNodo->nodo_anterior = NULL; // el puntero que apunta al siguiente nodo lo ponemos a null
    nuevoNodo->nodo_siguiente = NULL;
    nodo *ptrSiguiente = ptrCabecera;

    if (ptrCabecera == NULL){//si no hay mas nodos lo metemos detras detras de la cabecera
        ptrCabecera = nuevoNodo;
    }
   ptrFinal = insertaFinal(nuevoNodo, ptrFinal, ptrCabecera);//inserta final cambia los punteros de final e inicio para que se coloquen al final.
  }
  }
closedir (dir);
 /*----------FIN----LISTA---------*/
   mostrarLista(ptrCabecera, ptrFinal);


  do {
    printf("0. Salir.\n ");
    printf("1. Avanzar: muestra la siguiente imagen.\n ");
    printf("2. Retroceder: muestra la imagen anterior.\n ");
    printf("3. Borrar: elimina la imagen que se esté mostrando actualmente y visualiza el nombre de la imagen siguiente.\n ");
    printf("4. Limpiar: elimina todas las imágenes de la lista.\n");
    printf("5. Cargar: carga la lista doblemente enlazada circular con las imágenes almacenadas en el directorio que se indique.\n");
    printf("Elija una opcion: \n");
    scanf("%d", &menu);

      switch (menu) {
        case 1:

              break;
        case 2:

              break;
        case 3:

              break;
        case 4:
              
              break;

        case 5: 

              break;
        default:

              break;


      }


  } while(menu != 0);
    printf("Saliendo del programa...\n");
    system ("pause");
    return 0;
}//MAIN


void mostrarLista(nodo *ptrCabecera, nodo *ptrFinal){//muestra la lista
    if(ptrCabecera == NULL){// excepcion
        printf("\n========================\n Fichero de datos vacio\n========================\n");
    }
    else{
        nodo *ptrSiguiente = ptrCabecera;
        while(ptrSiguiente != NULL || ptrSiguiente == ptrFinal){
            visualiza(ptrSiguiente->datos);
            ptrSiguiente = ptrSiguiente->nodo_siguiente;
        }
    }
}



void visualiza(datos fotografias){
    printf("\nNombre fotos: %s", fotografias.imagen);
}




nodo* insertaFinal(nodo *nuevoNodo, nodo *ptrFinal,nodo *ptrCabecera){//inserta al final
  if(ptrFinal == NULL){
    return nuevoNodo;
  }
  else{
    ptrFinal->nodo_siguiente = nuevoNodo;
    nuevoNodo -> nodo_anterior = ptrFinal;
    nuevoNodo ->nodo_siguiente = ptrCabecera;
    ptrCabecera -> nodo_anterior = nuevoNodo;
    ptrFinal = nuevoNodo;
    return nuevoNodo;// devolvemos nuevo nodo en lugar de un puntero doble
  }
}



void siguiente(nodo ptrSiguiente, nodo *ptrCabecera, nodo *ptrFinal){//muestra la lista
    if(ptrCabecera == NULL){// excepcion
        printf("\n========================\n Fichero de datos vacio\n========================\n");
    }
    else{
        ptrSiguiente = ptrSiguiente->nodo_siguiente;
        visualiza(ptrSiguiente->datos);
        }
      }
void anterior(nodo *ptrCabecera, nodo *ptrFinal){//muestra la lista

    if(ptrCabecera == NULL){// excepcion
        printf("\n========================\n Fichero de datos vacio\n========================\n");
    }
    else{
        nodo *ptrAnterior = ptrCabecera;
        ptrAnterior = ptrAnterior->nodo_anterior;
        visualiza(ptrAnterior->datos);
        }
      }
void borrar(nodo *ptrSiguiente, nodo *ptrFinal,nodo *ptrCabecera, nodo *nuevoNodo){
  if(ptrCabecera == NULL || ptrFinal == NULL){
      printf("Cola vacia no se puede eliminar nada!!!!!!!!!!");
  }else if(ptrSiguiente->nodo_anterior == ptrFinal){
    ptrSiguiente -> nodo_siguiente->nodo_anterior = ptrFinal;
    ptrFinal -> nodo_siguiente = ptrSiguiente -> nodo_siguiente -> nodo_anterior;
    ptrCabecera = ptrFinal-> nodo_siguiente;
    free(ptrSiguiente);
  }else if(ptrSiguiente -> nodo_siguiente == ptrCabecera){
    ptrSiguiente -> nodo_anterior -> nodo_siguiente = ptrCabecera;
    ptrFinal = ptrSiguiente -> nodo_anterior;
    ptrCabecera -> nodo_anterior = ptrSiguiente -> nodo_anterior -> nodo_siguiente;
    free(nuevoNodo);
  }else if(ptrSiguiente -> nodo_siguiente == ptrSiguiente -> nodo_anterior ){
    free(nuevoNodo);
    printf("Cola vacia!!");
  }else if(ptrSiguiente -> nodo_anterior == ptrCabecera && ptrSiguiente -> nodo_anterior -> nodo_siguiente == ptrFinal){
      ptrCabecera = ptrSiguiente -> nodo_anterior;
      ptrFinal = ptrSiguiente ->nodo_siguiente;
  }else{
    ptrSiguiente -> nodo_anterior -> nodo_siguiente = ptrSiguiente -> nodo_siguiente;
    ptrSiguiente -> nodo_siguiente ->nodo_anterior = ptrSiguiente -> nodo_anterior;
    free(ptrSiguiente);
  }
}

void eliminarTodo(nodo *nuevoNodo, nodo *ptrFinal,nodo *ptrCabecera){
  if(ptrCabecera == NULL){// excepcion
      printf("\n========================\n Fichero de datos vacio\n========================\n");
  }
  else{
      nodo *ptrSiguiente = ptrCabecera;
      while(ptrSiguiente != NULL || ptrSiguiente == ptrFinal){
          borrar(ptrSiguiente);
          ptrSiguiente = ptrSiguiente->nodo_siguiente;
      }
    }
  }
